package com.prasannjeet.battleship.model;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.SneakyThrows;
import org.springframework.data.annotation.Id;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 * @author Prasannjeet <strong>Description: </strong>
 * The primary class where the magic happens! It contains all the game data. Contains a battle board, ships, the
 * username, etc. It initializes the board with random ship positions. This model is updated every time a player or
 * their opponent makes a move. It also tells the client whether a player has won the match or not.
 */
@Data
@NoArgsConstructor
public class GameInstance {

    /**
     * The userId of the player. Autogenerated to a new random value every time the player starts a new game. Is
     * <b>not</b> the key-value for this model.
     */
    private String userId;

    /**
     * The username of player. Is the key-value for this model.
     */
    @Id private String userName;

    /**
     * One instance of battle board, which will contain 64 instances of battle cell.
     */
    private BattleBoard battleBoard;

    /**
     * List of ships. Will contain 5 different ships.
     */
    private List ships;

    /**
     * Contains value from 0 to 15. One for each cell. As all the five ships amount to 15 cells. The name should
     * probably be changed to <i>attackedCells</i>. Will be done in future updates. //TODO
     */
    private int attackedShips;

    /**
     * This shows the number of times this user has won games. Unlike other variables above that change every time
     * the user plays a new game. This values persists and increases if the player wins a game.
     */
    private int wonGames = 0;

    /**
     * Similar to the <i>wonGames</i> entry. This variable shows the number of times the user lost games.
     */
    private int lostGames = 0;

    /**
     * Initializing the board with random ship positions. Used by both players 1 and 2. Called only when a <b>new</b>
     * user plays the game.
     * @param userId User-Id of the player, which is generated in the controllers.
     * @param userName User-Name of the player which is given by the user itself in frontend.
     */
    public GameInstance(String userId, String userName) {
        this.userId = userId;
        this.userName = userName;
        this.attackedShips = 0;
        this.wonGames = 0;
        this.lostGames = 0;
        this.battleBoard = new BattleBoard();
        ships = new ArrayList<Ship>() {{
            add(new Ship(5, Ship.ShipNameList.CARRIER));
            add(new Ship(4, Ship.ShipNameList.CRUISER));
            add(new Ship(3, Ship.ShipNameList.SUBMARINE));
            add(new Ship(2, Ship.ShipNameList.DESTROYER));
            add(new Ship(1, Ship.ShipNameList.ATTACKER));
        }};
        for (Object ship : ships) {
            setRandomPositions(battleBoard, (Ship) ship);
        }
    }

    /**
     * Initializing the board with random ship positions. This constructor is used if a recurring player joins the game.
     * To this end, it is important to make sure the variables <i>wonGames</i> and <i>lostGames</i> persist the data.
     * @param userId User-Id of the player, which is generated by the controllers.
     * @param userName User-Name of the players which is given by the user itself in frontend.
     * @param wonGames The number of times the user won a game, accessed by the controller from already existing
     *                 instance.
     * @param lostGames The number of times the user lost a game, accessed by teh controller from already existing
     *                  instance in the repository.
     */
    public GameInstance (String userId, String userName, int wonGames, int lostGames) {
        this.userId = userId;
        this.userName = userName;
        this.attackedShips = 0;
        this.wonGames = wonGames;
        this.lostGames = lostGames;
        this.battleBoard = new BattleBoard();
        ships = new ArrayList<Ship>() {{
            add(new Ship(5, Ship.ShipNameList.CARRIER));
            add(new Ship(4, Ship.ShipNameList.CRUISER));
            add(new Ship(3, Ship.ShipNameList.SUBMARINE));
            add(new Ship(2, Ship.ShipNameList.DESTROYER));
            add(new Ship(1, Ship.ShipNameList.ATTACKER));
        }};
        for (Object ship : ships) {
            setRandomPositions(battleBoard, (Ship) ship);
        }
    }

    /**
     * Used by the constructor to set random ship positions of the board. Can be used for a bigger board and more ship
     * in future as well. However, if the ship is so large that it can never fit in a board, this method will enter
     * in an infinite loop.
     * @param battleBoard The board
     * @param ship The shp that needs to be allocated random position.
     */
    @SneakyThrows(NullPointerException.class)
    public void setRandomPositions(BattleBoard battleBoard, Ship ship) {
        boolean isHorizontal = returnRandomBoolean();
        BattleCell oneCell = null;
        Random random = new Random();
        int x = 0;
        int y = 0;
        do {
            if (isHorizontal) {
                x = random.nextInt(8 - ship.getSize() + 1);
                y = random.nextInt(8);
            } else {
                x = random.nextInt(8);
                y = random.nextInt(8 - ship.getSize() + 1);
            }

        } while (!areCellsEmpty(x, y, isHorizontal, battleBoard, ship.getSize()));
        if (isHorizontal)
            for (int i = 0; i < ship.getSize(); i++) {
                ship.getCoordinates()[i] = (x + i) * 10 + y;
                oneCell = battleBoard.getBattleCells()[x + i][y];
                oneCell.setContainsShip(true);
            }
        else
            for (int i = 0; i < ship.getSize(); i++) {
                ship.getCoordinates()[i] = x * 10 + (y + i);
                oneCell = battleBoard.getBattleCells()[x][y + i];
                oneCell.setContainsShip(true);
            }
        oneCell.setShipName(ship.getShipName());
    }

    /**
     * Used by the <b>setRandomPositions()</b> method. It checks if a sequence of cells in a battle board are empty,
     * so that a shp with a certain size can fit there.
     * @param x The x-coordinate of either the topmost or leftmost position of the ship, based on their position,
     *          either vertical or horizontal, respectively.
     * @param y The y-coordinate of either the topmost or leftmost position of the ship, based on their position,
     *          either vertical or horizontal, respectively.
     * @param isHorizontal Asks the caller whether the ship was placed horizontally or vertically.
     * @param battleBoard The battleboard.
     * @param shipSize The size of the ship.
     * @return Boolean value whether all the cells are empty or not, so that the shp can be accommodated there.
     */
    private boolean areCellsEmpty(int x, int y, boolean isHorizontal, BattleBoard battleBoard, int shipSize) {
        boolean flag = true;
        BattleCell oneCell = null;
        if (isHorizontal)
            for (int i = 0; i < shipSize; i++) {
                oneCell = battleBoard.getBattleCells()[x + i][y];
                if (oneCell.isContainsShip()) flag = false;
            }
        else
            for (int i = 0; i < shipSize; i++) {
                oneCell = battleBoard.getBattleCells()[x][y + i];
                if (oneCell.isContainsShip()) flag = false;
            }
        return flag;
    }

    public boolean returnRandomBoolean() {
        return (Math.random() < 0.5);
    }

    /**
     * Performs a set of actions when an enemy attacks this battle board. Following actions are performed:
     * <ol>
     *     <li>The variable <b>setAttackedByEnemy</b> is set to be true.</li>
     *     <li>If the cell contained ship, the variable <b>attackedShips</b> is increased by one.</li>
     *     <li>The attack count of a ship that was in that cell is also increased. This variable is currentlyl
     *     not used in the implementation. However it can be used in the future.</li>
     *     <li>If the cell contained a ship, a <i>true</i> value is returned. Else <i>false</i> is returned.</li>
     * </ol>
     * @param coordinate The coordinate of that cell. It is in int format which is later converted into x and y, as can
     *                   be seen in the implementation.
     * @return Boolean value whether the cell contained a ship or not.
     */
    public boolean enemyTurn (int coordinate) {
        int x = coordinate/10;
        int y = coordinate%10;
        BattleCell battleCell = this.getBattleBoard().getBattleCells()[x][y];
        battleCell.setAttackedByEnemy(true);
        if (battleCell.isContainsShip()) {
            this.attackedShips++;

            Ship.ShipNameList shipName = battleCell.getShipName();
            for (Object ship : ships) {
                if (((Ship)ship).getShipName() == shipName) {
                    ((Ship)ship).setAttackCount(((Ship)ship).getAttackCount()+1);
                }
            }
            return true;
        }
        else return false;
    }
}
